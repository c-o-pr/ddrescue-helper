# ddrescue_helper

GNU ddrescue is a command-line tool for copying or imaging
block storage devices (drives or paritions) that includes graceful 
accomodation of errors.

Ddrescue\_helper is a Mac-oriented (for now) bash script that helps
apply GNU dd\_rescue to recover from read errors on spinning drives.

Before I created this script, I had long been using Carbon Copy Cloner to make drive-to-drive backups of HFS+ media volumes. The copy-engine in CCC helpfully reports files for which read errors occur, which are rare, and I've coped by setting these files aside to keep from reusing the problematic part of the drive and recovering files from alternates.

As my drives have aged (some are more than 8 years old) they are becoming prone to errors (bit rot), but these errors are still rare compared to the size of the drives.

By watching CCC's live copy progress report, and goofing around with files that have errors, I've found that relatively small regions of the drive suffer from slow reads and errors.

I also found that rewriting these files using dd(1) doesn't result in the OS reallocating the file data areas, nor does it cause the HFS+ filesystem or drive logic to remap bad blocks.

I looked into building bad-block lists using SMART, but this was unweildy due to variations and inconsistencies in SMART reporting. Mac doesn't have either hdparm(8), nor badblocks(1). Linux now has decent support for HFS+ but I don't want to set up a separate system, dual-booting is a distraction, and VMs abstract away from SATA

The idea of for this script came about from dealing with media errors occuring during local backups of spinning drives containing single HFS+ data volumes, and trying to adapt to these errors and continue to use problematic drives by setting files that cover the errors. This worked until I ran into a situation where a media error affected volume metadata (inodes and journal) resulting 
the volume to become inaccessible. Working with the volume caused the system to hang and eventually crash.

# IS CONTINUTUNG TO USE A DRIVE WITH MEDIA ERRORS SANE?

My expeirence is that large (4TB+) cheap commodities spinning hard drives have unreliable areas that only get exposed when the drive is used very close to full for a long time.

I will make a wild-ass guess that the drive makers solve a binning problem by tolerating a spread of defects in shipped product and deferring the exposure of
these defects for as long as possible. The gambit is that customers won't become aware of the problem areas until the drive is well out of warranty and so old that accountability for failure is irrelevant. The implication of this wild assessment is that a well-used drive can be expected to suffer from some errors when heavily used, but still has life it in if you can find a way to deal with the problem areas. For example, one way to work around bad spots is to set-aside large files that cover them. Another is to encourage the drive to re-allocate bad sectors.



By running a scan over an entire drive, such defects can be accomodated by setting aside affected files and zapping bad-blocks to re-allocate according to the drives spare provisioning.

# WARNINGS

THE WISE DATA HOARDER WILL HAVE GOOD BACKUPS AND SIMPLY REPLACE A PROBLEM DRIVE. BUT THE FRUGAL OR BEREFT MAY HAVE NEED TO WORK WITH DEVICES AT HAND.

THIS SCRIPT HAS BEEN CODED WITH CARE, BUT UNEXPECTED BEHAVIORS ARE POSSIBLE. BASH IS PESKY BECAUSE IT RELIES HEAVILY ON TEXT SUBSTITUTION.

# HOW THIS HELPER WORKS

There are three modes of operation:

1. 'ddrescue_helper.sh -m | -u | -f \<device\>'
   Unount, mount, and fsck a drive or partition.
   Unmount/mount includes updating /etc/fstab (vifs on Mac) to prevent 
   auto-mount. This makes a device ready to be processed without interference 
   from the auto-mount capabilities of the system, and allows easy access to 
   integrrity check in same wrapper.
   
2. 'ddrescue_helper.sh -c [-N] \<label\> \<source\> \<destination\>'
   Copy a drive or partition (or file) to another device or file (image).
   The generates a read map of blocks that includes read errors. The magic of
   GNU ddrescue also produces a rate log which indicates device regions that 
   experienced an IO slowdown.
   Instead of a copy, you can perform a read scan by 
   specifying /dev/null as \<destination\>.
   \<label\> is a name for a folder created in the current working directory
   to conain the meta-data.
   If \<souce\> or \<destination\> are relative paths they are relative to
   this folder.
   
3. 'ddrescue_helper.sh -p -P -z \<label\> \<device\>'
   Use the block map generated by copy to print a list of files affected
   by read errors (HFS+ only) and zap blocks in areas affected by errors to
   nudge the drive to reallocate these areas. This is destructive to those 
   blocks, but it can allow recovery of space from large media, and can 
   enable fsck to repair a volume that was stuck at a read timeout.

While the helper is macOS / HFS+ centric, the script is made in a way to enable 
adding support for Linux and other filesystems.

# TODOs
- [] XXX -u works for device with intact accessible partition volume metadata but drive errors on metadata may cause a lockup before processing. Cover this in the usage notes
- [] ADD GPT / MBR / table recovery
- [] ADD Partition superblock recovery
- [] XXX Device id in OS may change between runs (doc)
- [] ADD selectale rate limit for -P
- [] ADD zap confirmation
- [] XXX Flesh out Linux
- [] ADD zap blocklist sanity check for drive/part metadata regions
- [] ADD -p -z checks for unmanagebly large numbers of problem blocks in the map
- [] ADD List of files to copy.
- [] ADD ext2,3,4 file lookup and fsck
- [] ADD FAT, NTFS file lookup and fsck
- [] ADD pass additional options to ddrescue
- [] ADD badblocks(8) style integration for ext3/4
- [] ADD prettify the output of -z and save it in a log
- [] ADD a summary of unreadble blocks in output of -z, inc failed retry
- [] ADD signal handling for suspend / resume / abort of helper
- [] XXX Encrypted drives not considered (doc)
- [] XXX currently ^C doesn't work after ^Z
- [] XXX -z Blocksize and zap alignment on 4K Advanced Format drives???
- [] XXX Revisit --odirect / --idirect options
- [] ADD Clear option to remove metadata for \<label\>
- [] XXX Revisit SMART scanning
- [] XXX Verify Label tolerates whitespace or disallow.
- [] XXX For -p -P Figure out a way to look up target device from map file, when input/output devices and Label could include whitespace. Anchor matches using "/dev/".
- [] XXX Devices must be /dev qualified although this could be inferred
- [x] XXX -P Slow reads block spread for best coverage.
- [x] XXX -p -P Adjust partition offset based on device specified
- [x] ADD rate log reporting for slow areas and related files
- [x] ADD copy destination overwrite comnfirmation
- [x] ADD check for map match to source / desk